#!/usr/bin/env python
import csv
import sys
from EPPs.common import StepEPP


class GenerateManifest96WellPlate(StepEPP):
    _use_load_config = False  # prevent the loading of the config file

    """Generate a CSV containing the all the columns for 96 well plate sample manifest to be sent to a customer."""

    # additional argument required for the location of the Hamilton input file so def __init__ customised
    def __init__(self, argv=None):
        super().__init__(argv)
        self.manifest = self.cmd_args.manifest

    @staticmethod
    def add_args(argparser):
        argparser.add_argument(
            '-m', '--manifest', type=str, required=True, help='Sample manifest generated by the LIMS'
        )

    def _run(self):
        # csv_dict will be a dictionary that consists of the lines to be present in the Hamilton input file. These are
        # then sorted into correct order and added to the csv_array which is used to write the file
        csv_dict = {}
        csv_array = []

        # define the column headers that will be used in the Hamilton input file and add to the csv_array to be
        # used to write the file
        csv_column_headers = ['Sample/Name', 'UDF/User Sample Name', 'Container/Type', 'Container/Name',
                              'Sample/Well Location','UDF/Sample Type','UDF/Prep Workflow','UDF/Coverage (X)',
                              'UDF/Required Yield (Gb)','UDF/Delivery','UDF/Project ID','UDF/Extraction Method',
                              'UDF/Quantification Method','UDF/User Quantification','UDF/Volume','UDF/Total Yield',
                              'UDF/Elution Buffer','UDF/Sex','UDF/Species','UDF/Genome Version','UDF/Analysis Type',
                              'UDF/User Prepared Library']
        csv_array.append(csv_column_headers)


        print(csv_array)

        # define the sets for listing the unique input and output containers
        unique_input_containers = set()
        unique_output_containers = set()

        step_udfs=self.process.udf

        # obtain all of the inputs for the step
        all_inputs = self.process.all_inputs()




        print(step_udfs)


        # find all the inputs for the step that are analytes (i.e. samples and not associated files)
        for artifact in all_inputs:
            if artifact.type == 'Analyte':

                unique_input_containers.add(artifact.container.name)

                # assemble each line of the Hamilton input file in the correct structure for the Hamilton
                csv_line = [artifact.name,'',step_udfs['Container'],artifact.container.name,artifact.location[1],'',
                step_udfs['Library Type'],step_udfs['Coverage (1)'],step_udfs['Required Yield (Gb) (1)'],
                step_udfs['fastq Merged or Split'],artifact.samples[0].project.name,'','','','','','','',
                step_udfs['Species (1)'],step_udfs['Genome Version (1)'],step_udfs['Analysis Type'],
                step_udfs['User Prepared Library']]



                # build a dictionary of the lines for the Hamilton input file with a key that facilitates the lines
                # being by input container then column then row
                csv_dict[artifact.container.name + artifact.location[1]] = csv_line



        # define the rows and columns in the input plate (standard 96 well plate pattern)
        rows = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H']
        columns = ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12']

        # add the lines to the csv_array that will be used to write the Hamilton input file
        for unique_input_container in sorted(unique_input_containers):
            for column in columns:
                for row in rows:
                    if unique_input_container + row + ":" + column in csv_dict.keys():
                        csv_array.append(csv_dict[unique_input_container + row + ":" + column])

        print(csv_array)

        # create and write the Hamilton input file, this must have the hamilton_input argument as the prefix as this is
        # used by Clarity LIMS to recognise the file and attach it to the step
        with open(self.manifest + '-manifest.csv', 'w') as f:
            writer = csv.writer(f)
            writer.writerows(csv_array)


if __name__ == '__main__':
    GenerateManifest96WellPlate().run()
