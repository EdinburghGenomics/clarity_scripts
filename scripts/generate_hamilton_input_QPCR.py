#!/usr/bin/env python
import csv
import sys

from EPPs.common import StepEPP, step_argparser


class GenerateHamiltonInputUPL(StepEPP):
    """"Generate a 2 row CSV containing the necessary information to for the Make QPCR Hamilton app - number of samples
    UCT plate barcode, DIL1 plate barcode and DIL2 plate barcode - 1st row is column headers, 2nd row is data"""

    # additional argument required for the location of the Hamilton input file so def _init_ customised
    def __init__(self, step_uri, username, password, log_file, hamilton_input):
        super().__init__(step_uri, username, password, log_file)
        self.hamilton_input = hamilton_input

    def _run(self):
        # csv_dict will be a dictionary that consists of the lines to be present in the Hamilton input file. These are
        # then sorted into correct order and added to the csv_array which is used to write the file
        csv_dict = {}
        csv_array = []

        # define the column headers that will be used in the Hamilton input file and add to the csv_array to be
        # used to write the file
        csv_column_headers = ['Number of Samples', 'UCT Plate Barcode', 'DIL1 Plate Barcode', 'DIL2 Plate Barcode',
                              'QPCR Plate Barcode']
        csv_array.append(csv_column_headers)

        # define the sets for listing the unique input and output containers
        unique_input_containers = set()
        unique_output_containers = set()

        # obtain all of the inputs for the step
        all_inputs = self.process.all_inputs()
        input_analytes = set()

        # find all the inputs for the step that are analytes (i.e. samples and not associated files) then add them to a set
        for input in all_inputs:
            if input.type == 'Analyte':
                input_analytes.add(input)
                output = self.process.outputs_per_input(input.id, Analyte=True)
                # the script is only compatible with 1 output for each input i.e. replicates are not allowed
                if len(output) > 1:
                    print('Multiple outputs found for an input %s. This step is not compatible with replicates.' % (
                        input.name))
                    sys.exit(1)

                # build a list of the unique input containers for checking that no more than 1 is present and for importing
                # container name into CSV
                # Build a list of unique output containers as no more than 1 plate
                unique_input_containers.add(input.container.name)

                unique_output_containers.add(output[0].container.name)

        # check the number of input containers
        if len(unique_input_containers) > 1:
            print('Maximum number of input plates is 1. There are %s output plates in the step.' % (
                str(len(unique_input_containers))))
            sys.exit(1)
        # check the number of output containers
        if len(unique_output_containers) > 1:
            print('Maximum number of output plates is 1. There are %s output plates in the step.' % (
                str(len(unique_output_containers))))
            sys.exit(1)

        DIL1_template="LP[0-9]{7}-DIL1"
        DIL1_barcode=self.process.udf['DIL1 Plate Barcode']
        DIL2_template="LP[0-9]{7}-DIL2"
        DIL2_barcode=self.process.udf['DIL2 Plate Barcode']


        #check that DIL1 and DIL2 plate barcodes have the correct format
        if not re.match(DIL1_template,DIL1_barcode):
                print("%s is not a valid DIL1 container name. Container names must match %s" % (DIL1_barcode, DIL1_template))
                sys.exit(1)

        if not re.match(DIL1_template,DIL1_barcode):
                print("%s is not a valid DIL2 container name. Container names must match %s" % (DIL2_barcode, DIL2_template))
                sys.exit(1)

        csv_array.append(len(input_analytes), unique_input_containers, DIL1_barcode,
                         DIL2_barcode, unique_output_containers)



        # create and write the Hamilton input file, this must have the hamilton_input argument as the prefix as this is used by
        # Clarity LIMS to recognise the file and attach it to the step
        with open(self.hamilton_input + '-hamilton_input.csv', 'w') as csvFile:
            writer = csv.writer(csvFile)
            writer.writerows(csv_array)
        csvFile.close()


def main():
    p = step_argparser()
    p.add_argument('-i', '--hamilton_input', type=str, required=True, help='Hamilton input file generated by LIMS')
    args = p.parse_args()

    action = GenerateHamiltonInputUPL(args.step_uri, args.username, args.password, args.log_file, args.hamilton_input)
    action.run()


if __name__ == '__main__':
    main()
